{"version":3,"file":"specification.js","sourceRoot":"","sources":["../../../../src/cli/models/extensions/specification.ts"],"names":[],"mappings":"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","sourcesContent":["import {ZodSchemaType, BaseConfigType, BaseSchema} from './schemas.js'\nimport {ExtensionInstance} from './extension-instance.js'\nimport {blocks} from '../../constants.js'\n\nimport {Result} from '@shopify/cli-kit/node/result'\nimport {capitalize} from '@shopify/cli-kit/common/string'\nimport {zod} from '@shopify/cli-kit/node/schema'\nimport {getPathValue, setPathValue} from '@shopify/cli-kit/common/object'\n\nexport type ExtensionFeature =\n  | 'ui_preview'\n  | 'function'\n  | 'theme'\n  | 'bundling'\n  | 'cart_url'\n  | 'esbuild'\n  | 'single_js_entry_path'\n  | 'app_config'\n\nexport interface TransformationConfig {\n  [key: string]: string\n}\n\nexport interface CustomTransformationConfig {\n  forward?: (obj: object) => object\n  reverse?: (obj: object) => object\n}\n\n/**\n * Extension specification with all the needed properties and methods to load an extension.\n */\nexport interface ExtensionSpecification<TConfiguration extends BaseConfigType = BaseConfigType> {\n  identifier: string\n  externalIdentifier: string\n  externalName: string\n  group?: string\n  additionalIdentifiers: string[]\n  partnersWebIdentifier: string\n  surface: string\n  registrationLimit: number\n  dependency?: string\n  graphQLType?: string\n  schema: ZodSchemaType<TConfiguration>\n  getBundleExtensionStdinContent?: (config: TConfiguration) => string\n  deployConfig?: (\n    config: TConfiguration,\n    directory: string,\n    apiKey: string,\n    moduleId?: string,\n  ) => Promise<{[key: string]: unknown} | undefined>\n  validate?: (config: TConfiguration & {path: string}, directory: string) => Promise<Result<unknown, string>>\n  preDeployValidation?: (extension: ExtensionInstance<TConfiguration>) => Promise<void>\n  buildValidation?: (extension: ExtensionInstance<TConfiguration>) => Promise<void>\n  hasExtensionPointTarget?(config: TConfiguration, target: string): boolean\n  appModuleFeatures: (config?: TConfiguration) => ExtensionFeature[]\n  transform?: (content: object) => object\n  reverseTransform?: (content: object) => object\n}\n\n/**\n * These fields are forbidden when creating a new ExtensionSpec\n * They belong to the ExtensionSpec interface, but the values are obtained from the API\n * and should not be set by us locally\n */\nexport type ForbiddenFields =\n  | 'registrationLimit'\n  | 'category'\n  | 'externalIdentifier'\n  | 'externalName'\n  | 'name'\n  | 'surface'\n\n/**\n * Partial ExtensionSpec type used when creating a new ExtensionSpec, the only mandatory field is the identifier\n */\nexport interface CreateExtensionSpecType<TConfiguration extends BaseConfigType = BaseConfigType>\n  extends Partial<Omit<ExtensionSpecification<TConfiguration>, ForbiddenFields>> {\n  identifier: string\n  appModuleFeatures: (config?: TConfiguration) => ExtensionFeature[]\n}\n\n/**\n * Create a new ui extension spec.\n *\n * Everything but \"identifer\" is optional.\n * ```ts\n * identifier: string // unique identifier for the extension type\n * externalIdentifier: string // identifier used externally (default: same as \"identifier\")\n * partnersWebIdentifier: string // identifier used in the partners web UI (default: same as \"identifier\")\n * surface?: string // surface where the extension is going to be rendered (default: 'unknown')\n * dependency?: {name: string; version: string} // dependency to be added to the extension's package.json\n * graphQLType?: string // GraphQL type of the extension (default: same as \"identifier\")\n * schema?: ZodSchemaType<TConfiguration> // schema used to validate the extension's configuration (default: BaseUIExtensionSchema)\n * getBundleExtensionStdinContent?: (configuration: TConfiguration) => string // function to generate the content of the stdin file used to bundle the extension\n * validate?: (configuration: TConfiguration, directory: string) => Promise<Result<undefined, Error>> // function to validate the extension's configuration\n * preDeployValidation?: (configuration: TConfiguration) => Promise<void> // function to validate the extension's configuration before deploying it\n * deployConfig?: (configuration: TConfiguration, directory: string) => Promise<{[key: string]: unknown}> // function to generate the extensions configuration payload to be deployed\n * hasExtensionPointTarget?: (configuration: TConfiguration, target: string) => boolean // function to determine if the extension has a given extension point target\n * ```\n */\nexport function createExtensionSpecification<TConfiguration extends BaseConfigType = BaseConfigType>(\n  spec: CreateExtensionSpecType<TConfiguration>,\n): ExtensionSpecification<TConfiguration> {\n  const defaults = {\n    // these two fields are going to be overridden by the extension specification API response,\n    // but we need them to have a default value for tests\n    externalIdentifier: `${spec.identifier}_external`,\n    additionalIdentifiers: [],\n    externalName: capitalize(spec.identifier.replace(/_/g, ' ')),\n    surface: 'test-surface',\n    partnersWebIdentifier: spec.identifier,\n    schema: BaseSchema as ZodSchemaType<TConfiguration>,\n    registrationLimit: blocks.extensions.defaultRegistrationLimit,\n    transform: spec.transform,\n    reverseTransform: spec.reverseTransform,\n  }\n  return {...defaults, ...spec}\n}\n\n/**\n * Create a new app config extension spec. This factory method for creating app config extensions is created for two\n * reasons:\n *   - schema needs to be casted to ZodSchemaType<TConfiguration>\n *   - App config extensions have default transform and reverseTransform functions\n\n */\nexport function createConfigExtensionSpecification<TConfiguration extends BaseConfigType = BaseConfigType>(spec: {\n  identifier: string\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  schema: zod.ZodObject<any>\n  appModuleFeatures?: (config?: TConfiguration) => ExtensionFeature[]\n  transformConfig?: TransformationConfig | CustomTransformationConfig\n}): ExtensionSpecification<TConfiguration> {\n  const appModuleFeatures = spec.appModuleFeatures ?? (() => [])\n  return createExtensionSpecification({\n    identifier: spec.identifier,\n    // This casting is required because `name` and `type` are mandatory for the existing extension spec configurations,\n    // however, app config extensions config content is parsed from the `shopify.app.toml`\n    schema: spec.schema as unknown as ZodSchemaType<TConfiguration>,\n    appModuleFeatures: appModuleFeatures().includes('app_config')\n      ? appModuleFeatures\n      : () => appModuleFeatures().concat('app_config'),\n    transform: resolveAppConfigTransform(spec.transformConfig),\n    reverseTransform: resolveReverseAppConfigTransform(spec.schema, spec.transformConfig),\n  })\n}\n\nfunction resolveAppConfigTransform(transformConfig?: TransformationConfig | CustomTransformationConfig) {\n  if (!transformConfig) return (content: object) => defaultAppConfigTransform(content as {[key: string]: unknown})\n\n  if (Object.keys(transformConfig).includes('forward')) {\n    return (transformConfig as CustomTransformationConfig).forward!\n  } else {\n    return (content: object) => appConfigTransform(content, transformConfig)\n  }\n}\n\nfunction resolveReverseAppConfigTransform<T>(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  schema: zod.ZodType<T, any, any>,\n  transformConfig?: TransformationConfig | CustomTransformationConfig,\n) {\n  if (!transformConfig)\n    return (content: object) => defaultAppConfigReverseTransform(schema, content as {[key: string]: unknown})\n\n  if (Object.keys(transformConfig).includes('reverse')) {\n    return (transformConfig as CustomTransformationConfig).reverse!\n  } else {\n    return (content: object) => appConfigTransform(content, transformConfig, true)\n  }\n}\n\n/**\n * Given an object:\n * ```json\n * { source: { fieldSourceA: 'valueA' } }\n * ```\n *  and a tranform config content like this:\n * ```json\n * { 'target.fieldTargetA': 'source.fieldSourceA'}\n * ```\n * the method returns the following object:\n * ```json\n * { source: { fieldTargetA: 'valueA' } }\n * ```\n * The transformation can be applied in both ways depending on the reverse parameter\n *\n * @param content - The objet to be transformed\n * @param config - The transformation config\n * @param reverse - If true, the transformation will be applied in reverse\n *\n * @returns the transformed object\n */\n\nfunction appConfigTransform(\n  content: object,\n  config: TransformationConfig | CustomTransformationConfig,\n  reverse = false,\n): object {\n  const transformedContent = {}\n\n  for (const [mappedPath, objectPath] of Object.entries(config)) {\n    const originPath = reverse ? mappedPath : objectPath\n    const targetPath = reverse ? objectPath : mappedPath\n    const sourceValue = getPathValue(content, originPath)\n    if (sourceValue !== undefined) setPathValue(transformedContent, targetPath, sourceValue)\n  }\n\n  return transformedContent\n}\n\n/**\n * Flat the configuration object to a single level object. This is the schema expected by the server side.\n * ```json\n * {\n *   pos: {\n *    embedded = true\n *   }\n * }\n * ```\n * will be flattened to:\n * ```json\n * {\n *  embedded = true\n * }\n * ```\n * @param content - The objet to be flattened\n *\n * @returns A single level object\n */\nfunction defaultAppConfigTransform(content: {[key: string]: unknown}) {\n  const firstKey = Object.keys(content)[0]\n  return (firstKey ? content[firstKey] : content) as {[key: string]: unknown}\n}\n\n/**\n * Nest the content inside the first level object expected by the local schema.\n * ```json\n * {\n *  embedded = true\n * }\n * ```\n * will be flattened to applying the proper schema will return:\n * ```json\n * {\n *   pos: {\n *    embedded = true\n *   }\n * }\n * ```\n * @param content - The objet to be nested\n *\n * @returns The nested object\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction defaultAppConfigReverseTransform<T>(schema: zod.ZodType<T, any, any>, content: {[key: string]: unknown}) {\n  const configSection: {[key: string]: unknown} = {}\n  const firstLevelObjectName = Object.keys(schema._def.shape())[0]!\n  configSection[firstLevelObjectName] = content\n  return configSection\n}\n"]}