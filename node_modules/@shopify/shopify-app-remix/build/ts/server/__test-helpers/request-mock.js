"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.skipMockChecks = exports.validateMocks = exports.mockExternalRequests = exports.mockExternalRequest = void 0;
var tslib_1 = require("tslib");
var jest_fetch_mock_1 = tslib_1.__importDefault(require("jest-fetch-mock"));
var requestMocks = [];
var skipMockChecksFlag = false;
function mockExternalRequest(_a) {
    var request = _a.request, response = _a.response;
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var _b, body, init;
        return tslib_1.__generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    requestMocks.push({ request: request, response: response });
                    return [4 /*yield*/, mockParams(response)];
                case 1:
                    _b = _c.sent(), body = _b.body, init = _b.init;
                    jest_fetch_mock_1.default.mockResponse(body, init);
                    return [2 /*return*/];
            }
        });
    });
}
exports.mockExternalRequest = mockExternalRequest;
function mockExternalRequests() {
    var mocks = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        mocks[_i] = arguments[_i];
    }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var parsedResponses, mocks_1, mocks_1_1, mock, request, response, _a, body, init, e_1_1;
        var e_1, _b;
        return tslib_1.__generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    parsedResponses = [];
                    _c.label = 1;
                case 1:
                    _c.trys.push([1, 6, 7, 8]);
                    mocks_1 = tslib_1.__values(mocks), mocks_1_1 = mocks_1.next();
                    _c.label = 2;
                case 2:
                    if (!!mocks_1_1.done) return [3 /*break*/, 5];
                    mock = mocks_1_1.value;
                    request = mock.request, response = mock.response;
                    requestMocks.push({ request: request, response: response });
                    return [4 /*yield*/, mockParams(response)];
                case 3:
                    _a = _c.sent(), body = _a.body, init = _a.init;
                    parsedResponses.push([body, init]);
                    _c.label = 4;
                case 4:
                    mocks_1_1 = mocks_1.next();
                    return [3 /*break*/, 2];
                case 5: return [3 /*break*/, 8];
                case 6:
                    e_1_1 = _c.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 8];
                case 7:
                    try {
                        if (mocks_1_1 && !mocks_1_1.done && (_b = mocks_1.return)) _b.call(mocks_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                    return [7 /*endfinally*/];
                case 8:
                    jest_fetch_mock_1.default.mockResponses.apply(jest_fetch_mock_1.default, tslib_1.__spreadArray([], tslib_1.__read(parsedResponses), false));
                    return [2 /*return*/];
            }
        });
    });
}
exports.mockExternalRequests = mockExternalRequests;
function mockParams(response) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var _a;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _a = {};
                    return [4 /*yield*/, response.text()];
                case 1: return [2 /*return*/, (_a.body = _b.sent(),
                        _a.init = {
                            status: response.status,
                            statusText: response.statusText,
                            url: response.url,
                            headers: Object.fromEntries(response.headers.entries()),
                        },
                        _a)];
            }
        });
    });
}
function validateMocks() {
    var _a;
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var matchedRequests, _loop_1, _b, _c, _d, index, requestMock;
        var e_2, _e;
        return tslib_1.__generator(this, function (_f) {
            if (requestMocks.length === 0 && jest_fetch_mock_1.default.mock.calls.length === 0) {
                return [2 /*return*/];
            }
            matchedRequests = 0;
            _loop_1 = function (index, requestMock) {
                var request = requestMock.request;
                if (jest_fetch_mock_1.default.mock.calls.length === 0) {
                    return "continue";
                }
                matchedRequests++;
                var _g = tslib_1.__read(jest_fetch_mock_1.default.mock.calls[index], 2), url = _g[0], init = _g[1];
                var expected = {};
                var actual = {};
                if (request === null || request === void 0 ? void 0 : request.url) {
                    expected.url = new URL(request.url);
                    actual.url = new URL(url);
                }
                if (request === null || request === void 0 ? void 0 : request.method) {
                    expected.method = request.method;
                    actual.method = (init === null || init === void 0 ? void 0 : init.method) || 'GET';
                }
                if (request === null || request === void 0 ? void 0 : request.body) {
                    var bodyString = new TextDecoder('utf-8').decode(request.body);
                    expected.body = expect.stringContaining(bodyString);
                    actual.body = (_a = init === null || init === void 0 ? void 0 : init.body) === null || _a === void 0 ? void 0 : _a.toString();
                }
                if (request === null || request === void 0 ? void 0 : request.headers) {
                    expected.headers = {};
                    actual.headers = {};
                    // eslint-disable-next-line no-warning-comments
                    // TODO: we're currently not checking the headers properly. We should fix this.
                    Object.entries(request.headers).forEach(function (_a) {
                        var _b = tslib_1.__read(_a, 2), key = _b[0], value = _b[1];
                        expected.headers[key] = value;
                        actual.headers[key] = (init === null || init === void 0 ? void 0 : init.headers)[key];
                    });
                }
                try {
                    expect(actual).toEqual(expected);
                }
                catch (error) {
                    error.message = "".concat(init === null || init === void 0 ? void 0 : init.method, " request made to ").concat(url, " does not match expectation:\n\n").concat(error.message);
                    throw error;
                }
            };
            try {
                for (_b = tslib_1.__values(requestMocks.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    _d = tslib_1.__read(_c.value, 2), index = _d[0], requestMock = _d[1];
                    _loop_1(index, requestMock);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_e = _b.return)) _e.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
            if (requestMocks.length > matchedRequests) {
                throw new Error("Expected ".concat(requestMocks.length, " request(s) to be made but they were not:\n\n").concat(JSON.stringify(requestMocks, null, 2)));
            }
            if (jest_fetch_mock_1.default.mock.calls.length > matchedRequests) {
                throw new Error("".concat(jest_fetch_mock_1.default.mock.calls.length, " unexpected request(s) were made, make sure to mock all expected requests:\n\n").concat(JSON.stringify(jest_fetch_mock_1.default.mock.calls, null, 2)));
            }
            return [2 /*return*/];
        });
    });
}
exports.validateMocks = validateMocks;
function skipMockChecks(value) {
    skipMockChecksFlag = value;
}
exports.skipMockChecks = skipMockChecks;
beforeEach(function () {
    skipMockChecksFlag = false;
    requestMocks = [];
    jest_fetch_mock_1.default.resetMocks();
});
afterEach(function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (!!skipMockChecksFlag) return [3 /*break*/, 2];
                return [4 /*yield*/, validateMocks()];
            case 1:
                _a.sent();
                _a.label = 2;
            case 2: return [2 /*return*/];
        }
    });
}); });
//# sourceMappingURL=request-mock.js.map