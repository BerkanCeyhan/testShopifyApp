"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.authenticateAppProxyFactory = void 0;
var tslib_1 = require("tslib");
var clients_1 = require("../../../clients");
function authenticateAppProxyFactory(params) {
    var api = params.api, config = params.config, logger = params.logger;
    return function authenticate(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var searchParams, query, isValid, error_1, shop, sessionId, session, context_1, context;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        logger.info('Authenticating app proxy request');
                        searchParams = new URL(request.url).searchParams;
                        query = Object.fromEntries(searchParams.entries());
                        isValid = false;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, api.utils.validateHmac(query, {
                                signator: 'appProxy',
                            })];
                    case 2:
                        isValid = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        error_1 = _a.sent();
                        logger.info(error_1.message);
                        throw new Response(undefined, { status: 400, statusText: 'Bad Request' });
                    case 4:
                        if (!isValid) {
                            logger.info('App proxy request has invalid signature');
                            throw new Response(undefined, {
                                status: 400,
                                statusText: 'Bad Request',
                            });
                        }
                        shop = searchParams.get('shop');
                        sessionId = api.session.getOfflineId(shop);
                        return [4 /*yield*/, config.sessionStorage.loadSession(sessionId)];
                    case 5:
                        session = _a.sent();
                        if (!session) {
                            context_1 = {
                                liquid: liquid,
                                session: undefined,
                                admin: undefined,
                                storefront: undefined,
                            };
                            return [2 /*return*/, context_1];
                        }
                        context = {
                            liquid: liquid,
                            session: session,
                            admin: (0, clients_1.adminClientFactory)({ params: params, session: session }),
                            storefront: (0, clients_1.storefrontClientFactory)({ params: params, session: session }),
                        };
                        return [2 /*return*/, context];
                }
            });
        });
    };
}
exports.authenticateAppProxyFactory = authenticateAppProxyFactory;
var liquid = function (body, initAndOptions) {
    if (typeof initAndOptions !== 'object') {
        return new Response(body, {
            status: initAndOptions || 200,
            headers: {
                'Content-Type': 'application/liquid',
            },
        });
    }
    var _a = initAndOptions || {}, layout = _a.layout, responseInit = tslib_1.__rest(_a, ["layout"]);
    var responseBody = layout === false ? "{% layout none %} ".concat(body) : body;
    var headers = new Headers(responseInit.headers);
    headers.set('Content-Type', 'application/liquid');
    return new Response(responseBody, tslib_1.__assign(tslib_1.__assign({}, responseInit), { headers: headers }));
};
//# sourceMappingURL=authenticate.js.map