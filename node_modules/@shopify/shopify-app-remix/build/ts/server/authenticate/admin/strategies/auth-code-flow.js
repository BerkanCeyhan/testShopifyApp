"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthCodeFlowStrategy = void 0;
var tslib_1 = require("tslib");
var shopify_api_1 = require("@shopify/shopify-api");
var helpers_1 = require("../helpers");
var helpers_2 = require("../../helpers");
var AuthCodeFlowStrategy = /** @class */ (function () {
    function AuthCodeFlowStrategy(_a) {
        var api = _a.api, config = _a.config, logger = _a.logger;
        this.api = api;
        this.config = config;
        this.logger = logger;
    }
    AuthCodeFlowStrategy.prototype.respondToOAuthRequests = function (request) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, api, config, url, isAuthRequest, isAuthCallbackRequest, shop;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this, api = _a.api, config = _a.config;
                        url = new URL(request.url);
                        isAuthRequest = url.pathname === config.auth.path;
                        isAuthCallbackRequest = url.pathname === config.auth.callbackPath;
                        if (!(isAuthRequest || isAuthCallbackRequest)) return [3 /*break*/, 4];
                        shop = api.utils.sanitizeShop(url.searchParams.get('shop'));
                        if (!shop)
                            throw new Response('Shop param is invalid', { status: 400 });
                        if (!isAuthRequest) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.handleAuthBeginRequest(request, shop)];
                    case 1: throw _b.sent();
                    case 2: return [4 /*yield*/, this.handleAuthCallbackRequest(request, shop)];
                    case 3: throw _b.sent();
                    case 4:
                        if (!!(0, helpers_2.getSessionTokenHeader)(request)) return [3 /*break*/, 6];
                        // This is a document request that doesn't contain a session token. We check if the app is installed.
                        // If the app isn't installed, we initiate the OAuth auth code flow.
                        // Requests with a header can only happen after the app is installed.
                        return [4 /*yield*/, this.ensureInstalledOnShop(request)];
                    case 5:
                        // This is a document request that doesn't contain a session token. We check if the app is installed.
                        // If the app isn't installed, we initiate the OAuth auth code flow.
                        // Requests with a header can only happen after the app is installed.
                        _b.sent();
                        _b.label = 6;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    AuthCodeFlowStrategy.prototype.authenticate = function (request, session, shop) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, api, config, logger;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this, api = _a.api, config = _a.config, logger = _a.logger;
                        if (!!session) return [3 /*break*/, 2];
                        logger.debug('No session found, redirecting to OAuth', { shop: shop });
                        return [4 /*yield*/, (0, helpers_1.redirectToAuthPage)({ config: config, logger: logger, api: api }, request, shop)];
                    case 1:
                        _b.sent();
                        return [3 /*break*/, 4];
                    case 2:
                        if (!!session.isActive(config.scopes)) return [3 /*break*/, 4];
                        logger.debug('Found a session, but it has expired, redirecting to OAuth', { shop: shop });
                        return [4 /*yield*/, (0, helpers_1.redirectToAuthPage)({ config: config, logger: logger, api: api }, request, shop)];
                    case 3:
                        _b.sent();
                        _b.label = 4;
                    case 4:
                        logger.debug('Found a valid session', { shop: shop });
                        return [2 /*return*/, session];
                }
            });
        });
    };
    AuthCodeFlowStrategy.prototype.ensureInstalledOnShop = function (request) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, api, config, logger, url, shop, offlineSession, isEmbedded, error_1;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this, api = _a.api, config = _a.config, logger = _a.logger;
                        (0, helpers_1.validateShopAndHostParams)({ api: api, config: config, logger: logger }, request);
                        url = new URL(request.url);
                        shop = url.searchParams.get('shop');
                        // Ensure app is installed
                        logger.debug('Ensuring app is installed on shop', { shop: shop });
                        return [4 /*yield*/, this.hasValidOfflineId(request)];
                    case 1:
                        if (!(_b.sent())) {
                            logger.info("Could not find a shop, can't authenticate request");
                            throw new Response(undefined, {
                                status: 400,
                                statusText: 'Bad Request',
                            });
                        }
                        return [4 /*yield*/, this.getOfflineSession(request)];
                    case 2:
                        offlineSession = _b.sent();
                        isEmbedded = url.searchParams.get('embedded') === '1';
                        if (!!offlineSession) return [3 /*break*/, 5];
                        logger.info("Shop hasn't installed app yet, redirecting to OAuth", {
                            shop: shop,
                        });
                        if (!isEmbedded) return [3 /*break*/, 3];
                        (0, helpers_1.redirectWithExitIframe)({ api: api, config: config, logger: logger }, request, shop);
                        return [3 /*break*/, 5];
                    case 3: return [4 /*yield*/, (0, helpers_1.beginAuth)({ api: api, config: config, logger: logger }, request, false, shop)];
                    case 4: throw _b.sent();
                    case 5:
                        shop = shop || offlineSession.shop;
                        if (!(config.isEmbeddedApp && !isEmbedded)) return [3 /*break*/, 10];
                        _b.label = 6;
                    case 6:
                        _b.trys.push([6, 8, , 10]);
                        logger.debug('Ensuring offline session is valid before embedding', {
                            shop: shop,
                        });
                        return [4 /*yield*/, this.testSession(offlineSession)];
                    case 7:
                        _b.sent();
                        logger.debug('Offline session is still valid, embedding app', { shop: shop });
                        return [3 /*break*/, 10];
                    case 8:
                        error_1 = _b.sent();
                        return [4 /*yield*/, this.handleInvalidOfflineSession(error_1, request, shop)];
                    case 9:
                        _b.sent();
                        return [3 /*break*/, 10];
                    case 10: return [2 /*return*/];
                }
            });
        });
    };
    AuthCodeFlowStrategy.prototype.handleAuthBeginRequest = function (request, shop) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, api, config, logger;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this, api = _a.api, config = _a.config, logger = _a.logger;
                        logger.info('Handling OAuth begin request', { shop: shop });
                        if (!(config.isEmbeddedApp &&
                            request.headers.get('Sec-Fetch-Dest') === 'iframe')) return [3 /*break*/, 1];
                        logger.debug('Auth request in iframe detected, exiting iframe', { shop: shop });
                        throw (0, helpers_1.redirectWithExitIframe)({ api: api, config: config, logger: logger }, request, shop);
                    case 1: return [4 /*yield*/, (0, helpers_1.beginAuth)({ api: api, config: config, logger: logger }, request, false, shop)];
                    case 2: throw _b.sent();
                }
            });
        });
    };
    AuthCodeFlowStrategy.prototype.handleAuthCallbackRequest = function (request, shop) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, api, config, logger, _b, session, responseHeaders, error_2;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = this, api = _a.api, config = _a.config, logger = _a.logger;
                        logger.info('Handling OAuth callback request');
                        _c.label = 1;
                    case 1:
                        _c.trys.push([1, 8, , 10]);
                        return [4 /*yield*/, api.auth.callback({
                                rawRequest: request,
                            })];
                    case 2:
                        _b = _c.sent(), session = _b.session, responseHeaders = _b.headers;
                        return [4 /*yield*/, config.sessionStorage.storeSession(session)];
                    case 3:
                        _c.sent();
                        if (!(config.useOnlineTokens && !session.isOnline)) return [3 /*break*/, 5];
                        logger.info('Requesting online access token for offline session');
                        return [4 /*yield*/, (0, helpers_1.beginAuth)({ api: api, config: config, logger: logger }, request, true, shop)];
                    case 4:
                        _c.sent();
                        _c.label = 5;
                    case 5: return [4 /*yield*/, (0, helpers_1.triggerAfterAuthHook)({ api: api, config: config, logger: logger }, session, request)];
                    case 6:
                        _c.sent();
                        return [4 /*yield*/, (0, helpers_1.redirectToShopifyOrAppRoot)(request, { api: api, config: config, logger: logger }, responseHeaders)];
                    case 7: throw _c.sent();
                    case 8:
                        error_2 = _c.sent();
                        if (error_2 instanceof Response)
                            throw error_2;
                        return [4 /*yield*/, this.oauthCallbackError(error_2, request, shop)];
                    case 9: throw _c.sent();
                    case 10: return [2 /*return*/];
                }
            });
        });
    };
    AuthCodeFlowStrategy.prototype.getOfflineSession = function (request) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var offlineId;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getOfflineSessionId(request)];
                    case 1:
                        offlineId = _a.sent();
                        return [2 /*return*/, this.config.sessionStorage.loadSession(offlineId)];
                }
            });
        });
    };
    AuthCodeFlowStrategy.prototype.hasValidOfflineId = function (request) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = Boolean;
                        return [4 /*yield*/, this.getOfflineSessionId(request)];
                    case 1: return [2 /*return*/, _a.apply(void 0, [_b.sent()])];
                }
            });
        });
    };
    AuthCodeFlowStrategy.prototype.getOfflineSessionId = function (request) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var api, url, shop;
            return tslib_1.__generator(this, function (_a) {
                api = this.api;
                url = new URL(request.url);
                shop = url.searchParams.get('shop');
                return [2 /*return*/, shop
                        ? api.session.getOfflineId(shop)
                        : api.session.getCurrentId({ isOnline: false, rawRequest: request })];
            });
        });
    };
    AuthCodeFlowStrategy.prototype.testSession = function (session) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var api, client;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        api = this.api;
                        client = new api.clients.Graphql({
                            session: session,
                        });
                        return [4 /*yield*/, client.query({
                                data: "#graphql\n        query shopifyAppShopName {\n          shop {\n            name\n          }\n        }\n      ",
                            })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    AuthCodeFlowStrategy.prototype.oauthCallbackError = function (error, request, shop) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var logger;
            return tslib_1.__generator(this, function (_a) {
                logger = this.logger;
                logger.error('Error during OAuth callback', { error: error.message });
                if (error instanceof shopify_api_1.CookieNotFound) {
                    return [2 /*return*/, this.handleAuthBeginRequest(request, shop)];
                }
                if (error instanceof shopify_api_1.InvalidHmacError ||
                    error instanceof shopify_api_1.InvalidOAuthError) {
                    return [2 /*return*/, new Response(undefined, {
                            status: 400,
                            statusText: 'Invalid OAuth Request',
                        })];
                }
                return [2 /*return*/, new Response(undefined, {
                        status: 500,
                        statusText: 'Internal Server Error',
                    })];
            });
        });
    };
    AuthCodeFlowStrategy.prototype.handleInvalidOfflineSession = function (error, request, shop) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, api, logger, config, message, context;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this, api = _a.api, logger = _a.logger, config = _a.config;
                        if (!(error instanceof shopify_api_1.HttpResponseError)) return [3 /*break*/, 4];
                        if (!(error.response.code === 401)) return [3 /*break*/, 2];
                        logger.info('Shop session is no longer valid, redirecting to OAuth', {
                            shop: shop,
                        });
                        return [4 /*yield*/, (0, helpers_1.beginAuth)({ api: api, config: config, logger: logger }, request, false, shop)];
                    case 1: throw _b.sent();
                    case 2:
                        message = JSON.stringify(error.response.body, null, 2);
                        logger.error("Unexpected error during session validation: ".concat(message), {
                            shop: shop,
                        });
                        throw new Response(undefined, {
                            status: error.response.code,
                            statusText: error.response.statusText,
                        });
                    case 3: return [3 /*break*/, 5];
                    case 4:
                        if (error instanceof shopify_api_1.GraphqlQueryError) {
                            context = { shop: shop };
                            if (error.response) {
                                context.response = JSON.stringify(error.response);
                            }
                            logger.error("Unexpected error during session validation: ".concat(error.message), context);
                            throw new Response(undefined, {
                                status: 500,
                                statusText: 'Internal Server Error',
                            });
                        }
                        _b.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    return AuthCodeFlowStrategy;
}());
exports.AuthCodeFlowStrategy = AuthCodeFlowStrategy;
//# sourceMappingURL=auth-code-flow.js.map