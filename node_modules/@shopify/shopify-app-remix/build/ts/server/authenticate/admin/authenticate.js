"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.authStrategyFactory = void 0;
var tslib_1 = require("tslib");
var helpers_1 = require("../helpers");
var billing_1 = require("./billing");
var helpers_2 = require("./helpers");
function authStrategyFactory(_a) {
    var strategy = _a.strategy, params = tslib_1.__rest(_a, ["strategy"]);
    var api = params.api, logger = params.logger, config = params.config;
    function respondToBouncePageRequest(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var url;
            return tslib_1.__generator(this, function (_a) {
                url = new URL(request.url);
                if (url.pathname === config.auth.patchSessionTokenPath) {
                    logger.debug('Rendering bounce page');
                    throw (0, helpers_2.renderAppBridge)({ config: config, logger: logger, api: api }, request);
                }
                return [2 /*return*/];
            });
        });
    }
    function respondToExitIframeRequest(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var url, destination;
            return tslib_1.__generator(this, function (_a) {
                url = new URL(request.url);
                if (url.pathname === config.auth.exitIframePath) {
                    destination = url.searchParams.get('exitIframe');
                    logger.debug('Rendering exit iframe page', { destination: destination });
                    throw (0, helpers_2.renderAppBridge)({ config: config, logger: logger, api: api }, request, { url: destination });
                }
                return [2 /*return*/];
            });
        });
    }
    function createContext(request, session, sessionToken) {
        var context = {
            admin: (0, helpers_2.createAdminApiContext)(request, session, {
                api: api,
                logger: logger,
                config: config,
            }),
            billing: {
                require: (0, billing_1.requireBillingFactory)(params, request, session),
                request: (0, billing_1.requestBillingFactory)(params, request, session),
                cancel: (0, billing_1.cancelBillingFactory)(params, request, session),
            },
            session: session,
            cors: (0, helpers_1.ensureCORSHeadersFactory)(params, request),
        };
        if (config.isEmbeddedApp) {
            return tslib_1.__assign(tslib_1.__assign({}, context), { sessionToken: sessionToken, redirect: (0, helpers_2.redirectFactory)(params, request) });
        }
        else {
            return context;
        }
    }
    return function authenticateAdmin(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, payload, shop, sessionId, existingSession, _b, session, errorOrResponse_1;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _c.trys.push([0, 12, , 13]);
                        (0, helpers_1.respondToBotRequest)(params, request);
                        (0, helpers_1.respondToOptionsRequest)(params, request);
                        return [4 /*yield*/, respondToBouncePageRequest(request)];
                    case 1:
                        _c.sent();
                        return [4 /*yield*/, respondToExitIframeRequest(request)];
                    case 2:
                        _c.sent();
                        return [4 /*yield*/, strategy.respondToOAuthRequests(request)];
                    case 3:
                        _c.sent();
                        if (!!(0, helpers_1.getSessionTokenHeader)(request)) return [3 /*break*/, 6];
                        (0, helpers_2.validateShopAndHostParams)(params, request);
                        return [4 /*yield*/, (0, helpers_2.ensureAppIsEmbeddedIfRequired)(params, request)];
                    case 4:
                        _c.sent();
                        return [4 /*yield*/, (0, helpers_2.ensureSessionTokenSearchParamIfRequired)(params, request)];
                    case 5:
                        _c.sent();
                        _c.label = 6;
                    case 6:
                        logger.info('Authenticating admin request');
                        return [4 /*yield*/, getSessionTokenContext(params, request)];
                    case 7:
                        _a = _c.sent(), payload = _a.payload, shop = _a.shop, sessionId = _a.sessionId;
                        logger.debug('Loading session from storage', { sessionId: sessionId });
                        if (!sessionId) return [3 /*break*/, 9];
                        return [4 /*yield*/, config.sessionStorage.loadSession(sessionId)];
                    case 8:
                        _b = _c.sent();
                        return [3 /*break*/, 10];
                    case 9:
                        _b = undefined;
                        _c.label = 10;
                    case 10:
                        existingSession = _b;
                        return [4 /*yield*/, strategy.authenticate(request, existingSession, shop)];
                    case 11:
                        session = _c.sent();
                        logger.debug('Request is valid, loaded session from session token', {
                            shop: session.shop,
                            isOnline: session.isOnline,
                        });
                        return [2 /*return*/, createContext(request, session, payload)];
                    case 12:
                        errorOrResponse_1 = _c.sent();
                        if (errorOrResponse_1 instanceof Response) {
                            (0, helpers_1.ensureCORSHeadersFactory)(params, request)(errorOrResponse_1);
                        }
                        throw errorOrResponse_1;
                    case 13: return [2 /*return*/];
                }
            });
        });
    };
}
exports.authStrategyFactory = authStrategyFactory;
function getSessionTokenContext(params, request) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var api, config, logger, headerSessionToken, searchParamSessionToken, sessionToken, payload, dest, shop_1, sessionId_1, url, shop, sessionId;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    api = params.api, config = params.config, logger = params.logger;
                    headerSessionToken = (0, helpers_1.getSessionTokenHeader)(request);
                    searchParamSessionToken = (0, helpers_1.getSessionTokenFromUrlParam)(request);
                    sessionToken = (headerSessionToken || searchParamSessionToken);
                    logger.debug('Attempting to authenticate session token', {
                        sessionToken: {
                            header: headerSessionToken,
                            search: searchParamSessionToken,
                        },
                    });
                    if (!config.isEmbeddedApp) return [3 /*break*/, 2];
                    return [4 /*yield*/, (0, helpers_1.validateSessionToken)({ config: config, logger: logger, api: api }, sessionToken)];
                case 1:
                    payload = _a.sent();
                    dest = new URL(payload.dest);
                    shop_1 = dest.hostname;
                    logger.debug('Session token is valid', { shop: shop_1, payload: payload });
                    sessionId_1 = config.useOnlineTokens
                        ? api.session.getJwtSessionId(shop_1, payload.sub)
                        : api.session.getOfflineId(shop_1);
                    return [2 /*return*/, { shop: shop_1, payload: payload, sessionId: sessionId_1 }];
                case 2:
                    url = new URL(request.url);
                    shop = url.searchParams.get('shop');
                    return [4 /*yield*/, api.session.getCurrentId({
                            isOnline: config.useOnlineTokens,
                            rawRequest: request,
                        })];
                case 3:
                    sessionId = _a.sent();
                    return [2 /*return*/, { shop: shop, sessionId: sessionId, payload: undefined }];
            }
        });
    });
}
//# sourceMappingURL=authenticate.js.map