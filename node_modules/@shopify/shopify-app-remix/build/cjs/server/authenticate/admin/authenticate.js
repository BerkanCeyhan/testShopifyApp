'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var ensureCorsHeaders = require('../helpers/ensure-cors-headers.js');
var validateSessionToken = require('../helpers/validate-session-token.js');
var getSessionTokenHeader = require('../helpers/get-session-token-header.js');
var rejectBotRequest = require('../helpers/reject-bot-request.js');
var respondToOptionsRequest = require('../helpers/respond-to-options-request.js');
var cancel = require('./billing/cancel.js');
var require$1 = require('./billing/require.js');
var request = require('./billing/request.js');
var createAdminApiContext = require('./helpers/create-admin-api-context.js');
var ensureAppIsEmbeddedIfRequired = require('./helpers/ensure-app-is-embedded-if-required.js');
var ensureSessionTokenSearchParamIfRequired = require('./helpers/ensure-session-token-search-param-if-required.js');
require('@shopify/shopify-api');
require('@remix-run/server-runtime');
var redirect = require('./helpers/redirect.js');
var renderAppBridge = require('./helpers/render-app-bridge.js');
var validateShopAndHostParams = require('./helpers/validate-shop-and-host-params.js');

function authStrategyFactory({
  strategy,
  ...params
}) {
  const {
    api,
    logger,
    config
  } = params;
  async function respondToBouncePageRequest(request) {
    const url = new URL(request.url);
    if (url.pathname === config.auth.patchSessionTokenPath) {
      logger.debug('Rendering bounce page');
      throw renderAppBridge.renderAppBridge({
        config,
        logger,
        api
      }, request);
    }
  }
  async function respondToExitIframeRequest(request) {
    const url = new URL(request.url);
    if (url.pathname === config.auth.exitIframePath) {
      const destination = url.searchParams.get('exitIframe');
      logger.debug('Rendering exit iframe page', {
        destination
      });
      throw renderAppBridge.renderAppBridge({
        config,
        logger,
        api
      }, request, {
        url: destination
      });
    }
  }
  function createContext(request$1, session, sessionToken) {
    const context = {
      admin: createAdminApiContext.createAdminApiContext(request$1, session, {
        api,
        logger,
        config
      }),
      billing: {
        require: require$1.requireBillingFactory(params, request$1, session),
        request: request.requestBillingFactory(params, request$1, session),
        cancel: cancel.cancelBillingFactory(params, request$1, session)
      },
      session,
      cors: ensureCorsHeaders.ensureCORSHeadersFactory(params, request$1)
    };
    if (config.isEmbeddedApp) {
      return {
        ...context,
        sessionToken,
        redirect: redirect.redirectFactory(params, request$1)
      };
    } else {
      return context;
    }
  }
  return async function authenticateAdmin(request) {
    try {
      rejectBotRequest.respondToBotRequest(params, request);
      respondToOptionsRequest.respondToOptionsRequest(params, request);
      await respondToBouncePageRequest(request);
      await respondToExitIframeRequest(request);
      await strategy.respondToOAuthRequests(request);

      // If this is a valid request, but it doesn't have a session token header, this is a document request. We need to
      // ensure we're embedded if needed and we have the information needed to load the session.
      if (!getSessionTokenHeader.getSessionTokenHeader(request)) {
        validateShopAndHostParams.validateShopAndHostParams(params, request);
        await ensureAppIsEmbeddedIfRequired.ensureAppIsEmbeddedIfRequired(params, request);
        await ensureSessionTokenSearchParamIfRequired.ensureSessionTokenSearchParamIfRequired(params, request);
      }
      logger.info('Authenticating admin request');
      const {
        payload,
        shop,
        sessionId
      } = await getSessionTokenContext(params, request);
      logger.debug('Loading session from storage', {
        sessionId
      });
      const existingSession = sessionId ? await config.sessionStorage.loadSession(sessionId) : undefined;
      const session = await strategy.authenticate(request, existingSession, shop);
      logger.debug('Request is valid, loaded session from session token', {
        shop: session.shop,
        isOnline: session.isOnline
      });
      return createContext(request, session, payload);
    } catch (errorOrResponse) {
      if (errorOrResponse instanceof Response) {
        ensureCorsHeaders.ensureCORSHeadersFactory(params, request)(errorOrResponse);
      }
      throw errorOrResponse;
    }
  };
}
async function getSessionTokenContext(params, request) {
  const {
    api,
    config,
    logger
  } = params;
  const headerSessionToken = getSessionTokenHeader.getSessionTokenHeader(request);
  const searchParamSessionToken = getSessionTokenHeader.getSessionTokenFromUrlParam(request);
  const sessionToken = headerSessionToken || searchParamSessionToken;
  logger.debug('Attempting to authenticate session token', {
    sessionToken: {
      header: headerSessionToken,
      search: searchParamSessionToken
    }
  });
  if (config.isEmbeddedApp) {
    const payload = await validateSessionToken.validateSessionToken({
      config,
      logger,
      api
    }, sessionToken);
    const dest = new URL(payload.dest);
    const shop = dest.hostname;
    logger.debug('Session token is valid', {
      shop,
      payload
    });
    const sessionId = config.useOnlineTokens ? api.session.getJwtSessionId(shop, payload.sub) : api.session.getOfflineId(shop);
    return {
      shop,
      payload,
      sessionId
    };
  }
  const url = new URL(request.url);
  const shop = url.searchParams.get('shop');
  const sessionId = await api.session.getCurrentId({
    isOnline: config.useOnlineTokens,
    rawRequest: request
  });
  return {
    shop,
    sessionId,
    payload: undefined
  };
}

exports.authStrategyFactory = authStrategyFactory;
