'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var shopifyApi = require('@shopify/shopify-api');
var beginAuth = require('../helpers/begin-auth.js');
require('@shopify/shopify-api/runtime');
var redirectToAuthPage = require('../helpers/redirect-to-auth-page.js');
var redirectToShopifyOrAppRoot = require('../helpers/redirect-to-shopify-or-app-root.js');
require('@remix-run/server-runtime');
var redirectWithExitiframe = require('../helpers/redirect-with-exitiframe.js');
var getSessionTokenHeader = require('../../helpers/get-session-token-header.js');
var triggerAfterAuthHook = require('../helpers/trigger-after-auth-hook.js');
var validateShopAndHostParams = require('../helpers/validate-shop-and-host-params.js');
require('isbot');

class AuthCodeFlowStrategy {
  constructor({
    api,
    config,
    logger
  }) {
    this.api = void 0;
    this.config = void 0;
    this.logger = void 0;
    this.api = api;
    this.config = config;
    this.logger = logger;
  }
  async respondToOAuthRequests(request) {
    const {
      api,
      config
    } = this;
    const url = new URL(request.url);
    const isAuthRequest = url.pathname === config.auth.path;
    const isAuthCallbackRequest = url.pathname === config.auth.callbackPath;
    if (isAuthRequest || isAuthCallbackRequest) {
      const shop = api.utils.sanitizeShop(url.searchParams.get('shop'));
      if (!shop) throw new Response('Shop param is invalid', {
        status: 400
      });
      if (isAuthRequest) {
        throw await this.handleAuthBeginRequest(request, shop);
      } else {
        throw await this.handleAuthCallbackRequest(request, shop);
      }
    }
    if (!getSessionTokenHeader.getSessionTokenHeader(request)) {
      // This is a document request that doesn't contain a session token. We check if the app is installed.
      // If the app isn't installed, we initiate the OAuth auth code flow.
      // Requests with a header can only happen after the app is installed.
      await this.ensureInstalledOnShop(request);
    }
  }
  async authenticate(request, session, shop) {
    const {
      api,
      config,
      logger
    } = this;
    if (!session) {
      logger.debug('No session found, redirecting to OAuth', {
        shop
      });
      await redirectToAuthPage.redirectToAuthPage({
        config,
        logger,
        api
      }, request, shop);
    } else if (!session.isActive(config.scopes)) {
      logger.debug('Found a session, but it has expired, redirecting to OAuth', {
        shop
      });
      await redirectToAuthPage.redirectToAuthPage({
        config,
        logger,
        api
      }, request, shop);
    }
    logger.debug('Found a valid session', {
      shop
    });
    return session;
  }
  async ensureInstalledOnShop(request) {
    const {
      api,
      config,
      logger
    } = this;
    validateShopAndHostParams.validateShopAndHostParams({
      api,
      config,
      logger
    }, request);
    const url = new URL(request.url);
    let shop = url.searchParams.get('shop');

    // Ensure app is installed
    logger.debug('Ensuring app is installed on shop', {
      shop
    });
    if (!(await this.hasValidOfflineId(request))) {
      logger.info("Could not find a shop, can't authenticate request");
      throw new Response(undefined, {
        status: 400,
        statusText: 'Bad Request'
      });
    }
    const offlineSession = await this.getOfflineSession(request);
    const isEmbedded = url.searchParams.get('embedded') === '1';
    if (!offlineSession) {
      logger.info("Shop hasn't installed app yet, redirecting to OAuth", {
        shop
      });
      if (isEmbedded) {
        redirectWithExitiframe.redirectWithExitIframe({
          api,
          config,
          logger
        }, request, shop);
      } else {
        throw await beginAuth.beginAuth({
          api,
          config,
          logger
        }, request, false, shop);
      }
    }
    shop = shop || offlineSession.shop;
    if (config.isEmbeddedApp && !isEmbedded) {
      try {
        logger.debug('Ensuring offline session is valid before embedding', {
          shop
        });
        await this.testSession(offlineSession);
        logger.debug('Offline session is still valid, embedding app', {
          shop
        });
      } catch (error) {
        await this.handleInvalidOfflineSession(error, request, shop);
      }
    }
  }
  async handleAuthBeginRequest(request, shop) {
    const {
      api,
      config,
      logger
    } = this;
    logger.info('Handling OAuth begin request', {
      shop
    });

    // If we're loading from an iframe, we need to break out of it
    if (config.isEmbeddedApp && request.headers.get('Sec-Fetch-Dest') === 'iframe') {
      logger.debug('Auth request in iframe detected, exiting iframe', {
        shop
      });
      throw redirectWithExitiframe.redirectWithExitIframe({
        api,
        config,
        logger
      }, request, shop);
    } else {
      throw await beginAuth.beginAuth({
        api,
        config,
        logger
      }, request, false, shop);
    }
  }
  async handleAuthCallbackRequest(request, shop) {
    const {
      api,
      config,
      logger
    } = this;
    logger.info('Handling OAuth callback request');
    try {
      const {
        session,
        headers: responseHeaders
      } = await api.auth.callback({
        rawRequest: request
      });
      await config.sessionStorage.storeSession(session);
      if (config.useOnlineTokens && !session.isOnline) {
        logger.info('Requesting online access token for offline session');
        await beginAuth.beginAuth({
          api,
          config,
          logger
        }, request, true, shop);
      }
      await triggerAfterAuthHook.triggerAfterAuthHook({
        api,
        config,
        logger
      }, session, request);
      throw await redirectToShopifyOrAppRoot.redirectToShopifyOrAppRoot(request, {
        api,
        config,
        logger
      }, responseHeaders);
    } catch (error) {
      if (error instanceof Response) throw error;
      throw await this.oauthCallbackError(error, request, shop);
    }
  }
  async getOfflineSession(request) {
    const offlineId = await this.getOfflineSessionId(request);
    return this.config.sessionStorage.loadSession(offlineId);
  }
  async hasValidOfflineId(request) {
    return Boolean(await this.getOfflineSessionId(request));
  }
  async getOfflineSessionId(request) {
    const {
      api
    } = this;
    const url = new URL(request.url);
    const shop = url.searchParams.get('shop');
    return shop ? api.session.getOfflineId(shop) : api.session.getCurrentId({
      isOnline: false,
      rawRequest: request
    });
  }
  async testSession(session) {
    const {
      api
    } = this;
    const client = new api.clients.Graphql({
      session
    });
    await client.query({
      data: `#graphql
        query shopifyAppShopName {
          shop {
            name
          }
        }
      `
    });
  }
  async oauthCallbackError(error, request, shop) {
    const {
      logger
    } = this;
    logger.error('Error during OAuth callback', {
      error: error.message
    });
    if (error instanceof shopifyApi.CookieNotFound) {
      return this.handleAuthBeginRequest(request, shop);
    }
    if (error instanceof shopifyApi.InvalidHmacError || error instanceof shopifyApi.InvalidOAuthError) {
      return new Response(undefined, {
        status: 400,
        statusText: 'Invalid OAuth Request'
      });
    }
    return new Response(undefined, {
      status: 500,
      statusText: 'Internal Server Error'
    });
  }
  async handleInvalidOfflineSession(error, request, shop) {
    const {
      api,
      logger,
      config
    } = this;
    if (error instanceof shopifyApi.HttpResponseError) {
      if (error.response.code === 401) {
        logger.info('Shop session is no longer valid, redirecting to OAuth', {
          shop
        });
        throw await beginAuth.beginAuth({
          api,
          config,
          logger
        }, request, false, shop);
      } else {
        const message = JSON.stringify(error.response.body, null, 2);
        logger.error(`Unexpected error during session validation: ${message}`, {
          shop
        });
        throw new Response(undefined, {
          status: error.response.code,
          statusText: error.response.statusText
        });
      }
    } else if (error instanceof shopifyApi.GraphqlQueryError) {
      const context = {
        shop
      };
      if (error.response) {
        context.response = JSON.stringify(error.response);
      }
      logger.error(`Unexpected error during session validation: ${error.message}`, context);
      throw new Response(undefined, {
        status: 500,
        statusText: 'Internal Server Error'
      });
    }
  }
}

exports.AuthCodeFlowStrategy = AuthCodeFlowStrategy;
